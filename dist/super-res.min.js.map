{"version":3,"sources":["/source/super-res.js","/source/src/createRequestor.js","super-res.min.js","/source/src/super-res.js","/source/src/superagentAdapter.js","/source/src/actionDefaults.js"],"names":["global","factory","exports","module","require","define","amd","superRes","Q","superagent","Route","cacheManager","this","createResponseTransformer","transforms","response","resolve","reduce","memo","transform","header","body","applyRequestTransforms","data","canHaveData","method","methodUpper","toUpperCase","getParameters","defaultParamConfig","Object","getOwnPropertyNames","params","paramName","param","derivedParams","startsWith","slice","defaultParams","createCacheKeyGetter","route","reverse","JSON","stringify","checkCache","cache","key","deferred","defer","get","err","result","reject","found","promise","expandParams","computedParams","prop","createRequestor_js__assign","createRequestTransformer","createRequestor","url","action","config","actionDefaults","_getParameters","transformResponse","getCacheKey","caching","cacheDefault","arguments","length","undefined","fullParams","configuredHttpRequest","superagentAdapter","configureRequest","transformRequest","cacheKey","then","_ref","makeRequest","set","generateDefaultActions","resource","query","save","put","remove","superagentAdapter__exports","dataTransformer","toLowerCase","currentRequest","accept","responseType","headers","timeout","clearTimeout","withCredentials","transformedData","send","request","end","res","store","max","ttl","super_res__assign","actions","forEach","name","promiseWrapper","wrapperFunc","proxiedResource","actionFunction","_len","args","Array","_key","apply","super_res"],"mappings":"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","file":"super-res.min.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('q'), require('superagent'), require('route-parser'), require('cache-manager')) :\n    typeof define === 'function' && define.amd ? define(['q', 'superagent', 'route-parser', 'cache-manager'], factory) :\n    global.superRes = factory(global.Q, global.superagent, global.Route, global.cacheManager)\n}(this, function (Q, superagent, Route, cacheManager) { 'use strict';\n\n    'use strict';\n\n    var superagentAdapter__exports = {};\n\n    superagentAdapter__exports.configureRequest = function configureRequest(config, url, dataTransformer) {\n        const method = config.method.toLowerCase();\n        let currentRequest = superagent[method === 'delete' ? 'del' : method](url);\n\n        currentRequest = currentRequest.accept(config.responseType);\n        if (config.headers) {\n            currentRequest = currentRequest.set(config.headers);\n        }\n\n        if (config.timeout) {\n            currentRequest.timeout(config.timeout);\n        } else {\n            currentRequest.clearTimeout();\n        }\n\n        if (config.withCredentials) {\n            currentRequest = currentRequest.withCredentials();\n        }\n\n        const transformedData = dataTransformer(currentRequest.header);\n        if (transformedData) {\n            if (method === 'get') {\n                currentRequest = currentRequest.query(transformedData);\n            } else {\n                currentRequest = currentRequest.send(transformedData);\n            }\n        }\n\n        return currentRequest;\n    };\n\n    superagentAdapter__exports.makeRequest = function makeRequest(request) {\n        const deferred = Q.defer();\n        request.end((err, res) => {\n            if (err) {\n                deferred.reject(err);\n            } else {\n                deferred.resolve(res);\n            }\n        });\n        return deferred.promise;\n    };\n\n    var superagentAdapter = superagentAdapter__exports;\n\n    var actionDefaults = actionDefaults = {\n      method: 'GET',\n      responseType: 'json',\n      transformRequest: [],\n      transformResponse: [],\n      withCredentials: false,\n      cache: null\n    };\n\n    var createRequestor_js__assign = createRequestor_js__assign || require('object.assign');\n\n    const cacheDefault = {store: 'memory', max: 100, ttl: 1200};\n\n    function createResponseTransformer(transforms) {\n      return function applyResponseTransforms(response) {\n        return Q.resolve(transforms.reduce(function (memo, transform) {\n          return transform(memo, response.header);\n        }, response.body));\n      };\n    }\n\n    function applyRequestTransforms(transforms, header, data) {\n      return transforms.reduce(function (memo, transform) {\n        return transform(memo, header);\n      }, data);\n    }\n\n    function canHaveData(method) {\n      const methodUpper = method.toUpperCase();\n      return methodUpper === 'POST' || methodUpper === 'PUT' || methodUpper === 'PATCH';\n    }\n\n    function getParameters(defaultParamConfig) {\n      return Object.getOwnPropertyNames(defaultParamConfig)\n        .reduce((params, paramName) => {\n          let param = defaultParamConfig[paramName];\n          if (typeof param === 'function') {\n            params.derivedParams[paramName] = param;\n          } else if (typeof param === 'string' && param.startsWith('@')) {\n            params.derivedParams[paramName] = param.slice(1);\n          } else {\n            //add to default if it's not an @ or function param\n            params.defaultParams[paramName] = param;\n          }\n          return params;\n        }, {derivedParams: {}, defaultParams: {}});\n    }\n\n    function createCacheKeyGetter(route) {\n      return function getCacheKey(params, data) {\n        return route.reverse(params) + JSON.stringify(data || {});\n      }\n    }\n\n    function checkCache(method, cache, key) {\n      const deferred = Q.defer();\n      if (cache && method.toUpperCase() === 'GET') {\n        cache.get(key, (err, result) => {\n          if (err) {\n            deferred.reject(err);\n          } else if (result) {\n            deferred.resolve({found: true, result});\n          } else {\n            deferred.resolve({found: false});\n          }\n        })\n      } else {\n        deferred.resolve({found: false});\n      }\n      return deferred.promise;\n    }\n\n    function expandParams(derivedParams, defaultParams, data) {\n      return Object.getOwnPropertyNames(derivedParams)\n          .reduce((computedParams, prop) => {\n            let param = derivedParams[prop];\n            if(typeof param === 'function') {\n              computedParams[prop] = param();\n            } else {\n              computedParams[prop] = data[param];\n            }\n            return computedParams;\n          }, createRequestor_js__assign({}, defaultParams));\n    }\n\n    function createRequestTransformer(transform, data) {\n      return (header) => {\n        return data ? applyRequestTransforms(transform, header, data) : null;\n      }\n    }\n\n    function createRequestor(url, defaultParamConfig, action) {\n      const config = createRequestor_js__assign({url: url}, actionDefaults, action);\n      //const canHaveData = canHaveData(config.method);\n      const route = new Route(config.url);\n      const {derivedParams, defaultParams} = getParameters(defaultParamConfig || {});\n      const transformResponse = createResponseTransformer(config.transformResponse);\n      const getCacheKey = createCacheKeyGetter(route);\n\n      config.cache = config.cache === true ? cacheManager.caching(cacheDefault) : config.cache;\n\n      return function(params, data) {\n        if(arguments.length === 1 && canHaveData(config.method)) {\n          data = params;\n          params = undefined;\n        }\n        const fullParams = createRequestor_js__assign(expandParams(derivedParams, defaultParams, data), params);\n        const url = route.reverse(params);\n        const configuredHttpRequest = superagentAdapter.configureRequest(config, url, createRequestTransformer(config.transformRequest, data));\n        const cacheKey = getCacheKey(fullParams, data);\n        return checkCache(config.method, config.cache, cacheKey)\n          .then(function cacheSuccess({found, result}) {\n            if (found) {\n              return Q.resolve(result);\n            } else {\n                return superagentAdapter.makeRequest(configuredHttpRequest)\n                    .then(transformResponse)\n                    .then(function cacheResponse(response) {\n                        if (config.cache) {\n                            config.cache.set(cacheKey, response);\n                        }\n                        return Q.resolve(response);\n                    });\n            }\n\n          });\n      }\n    }\n\n    var super_res__assign = super_res__assign || require('object.assign');\n\n    const superRes = {};\n\n    function generateDefaultActions(url, defaultParams) {\n      const resource = {};\n\n      resource.get = createRequestor(url, defaultParams);\n      resource.query = resource.get;\n      resource.save = createRequestor(url, defaultParams, {method: 'POST'});\n      resource.put = createRequestor(url, defaultParams, {method: 'PUT'});\n      resource.remove = createRequestor(url, defaultParams, {method: 'DELETE'});\n      resource['delete'] = resource.remove;\n\n      return resource;\n    }\n\n    superRes.resource = (url, defaultParams, actions) => {\n      const resource = generateDefaultActions(url, defaultParams);\n      if (actions) {\n        Object.getOwnPropertyNames(actions).forEach((name) => {\n          resource[name] = createRequestor(url, defaultParams, actions[name]);\n        });\n      }\n      return resource;\n    };\n\n    superRes.promiseWrapper = function promiseWrapper(wrapperFunc) {\n      return (resource) => {\n        let proxiedResource = super_res__assign({}, resource);\n        Object.getOwnPropertyNames(resource).forEach((name) => {\n          let actionFunction = proxiedResource[name];\n          proxiedResource[name] = function (...args) {\n            let promise = actionFunction.apply(proxiedResource, args);\n            return wrapperFunc(promise);\n          }\n        });\n        return proxiedResource;\n      }\n    };\n\n    var super_res = superRes;\n\n    return super_res;\n\n}));\n","var assign = assign || require('object.assign');\n\nimport Q from 'q';\nimport request from 'superagent';\nimport Route from 'route-parser';\nimport cacheManager from 'cache-manager';\n\nimport superagentAdapter from './superagentAdapter.js';\nimport actionDefaults from './actionDefaults.js';\n\nconst cacheDefault = {store: 'memory', max: 100, ttl: 1200};\n\nfunction createResponseTransformer(transforms) {\n  return function applyResponseTransforms(response) {\n    return Q.resolve(transforms.reduce(function (memo, transform) {\n      return transform(memo, response.header);\n    }, response.body));\n  };\n}\n\nfunction applyRequestTransforms(transforms, header, data) {\n  return transforms.reduce(function (memo, transform) {\n    return transform(memo, header);\n  }, data);\n}\n\nfunction canHaveData(method) {\n  const methodUpper = method.toUpperCase();\n  return methodUpper === 'POST' || methodUpper === 'PUT' || methodUpper === 'PATCH';\n}\n\nfunction getParameters(defaultParamConfig) {\n  return Object.getOwnPropertyNames(defaultParamConfig)\n    .reduce((params, paramName) => {\n      let param = defaultParamConfig[paramName];\n      if (typeof param === 'function') {\n        params.derivedParams[paramName] = param;\n      } else if (typeof param === 'string' && param.startsWith('@')) {\n        params.derivedParams[paramName] = param.slice(1);\n      } else {\n        //add to default if it's not an @ or function param\n        params.defaultParams[paramName] = param;\n      }\n      return params;\n    }, {derivedParams: {}, defaultParams: {}});\n}\n\nfunction createCacheKeyGetter(route) {\n  return function getCacheKey(params, data) {\n    return route.reverse(params) + JSON.stringify(data || {});\n  }\n}\n\nfunction checkCache(method, cache, key) {\n  const deferred = Q.defer();\n  if (cache && method.toUpperCase() === 'GET') {\n    cache.get(key, (err, result) => {\n      if (err) {\n        deferred.reject(err);\n      } else if (result) {\n        deferred.resolve({found: true, result});\n      } else {\n        deferred.resolve({found: false});\n      }\n    })\n  } else {\n    deferred.resolve({found: false});\n  }\n  return deferred.promise;\n}\n\nfunction expandParams(derivedParams, defaultParams, data) {\n  return Object.getOwnPropertyNames(derivedParams)\n      .reduce((computedParams, prop) => {\n        let param = derivedParams[prop];\n        if(typeof param === 'function') {\n          computedParams[prop] = param();\n        } else {\n          computedParams[prop] = data[param];\n        }\n        return computedParams;\n      }, assign({}, defaultParams));\n}\n\nfunction createRequestTransformer(transform, data) {\n  return (header) => {\n    return data ? applyRequestTransforms(transform, header, data) : null;\n  }\n}\n\nexport default function createRequestor(url, defaultParamConfig, action) {\n  const config = assign({url: url}, actionDefaults, action);\n  //const canHaveData = canHaveData(config.method);\n  const route = new Route(config.url);\n  const {derivedParams, defaultParams} = getParameters(defaultParamConfig || {});\n  const transformResponse = createResponseTransformer(config.transformResponse);\n  const getCacheKey = createCacheKeyGetter(route);\n\n  config.cache = config.cache === true ? cacheManager.caching(cacheDefault) : config.cache;\n\n  return function(params, data) {\n    if(arguments.length === 1 && canHaveData(config.method)) {\n      data = params;\n      params = undefined;\n    }\n    const fullParams = assign(expandParams(derivedParams, defaultParams, data), params);\n    const url = route.reverse(params);\n    const configuredHttpRequest = superagentAdapter.configureRequest(config, url, createRequestTransformer(config.transformRequest, data));\n    const cacheKey = getCacheKey(fullParams, data);\n    return checkCache(config.method, config.cache, cacheKey)\n      .then(function cacheSuccess({found, result}) {\n        if (found) {\n          return Q.resolve(result);\n        } else {\n            return superagentAdapter.makeRequest(configuredHttpRequest)\n                .then(transformResponse)\n                .then(function cacheResponse(response) {\n                    if (config.cache) {\n                        config.cache.set(cacheKey, response);\n                    }\n                    return Q.resolve(response);\n                });\n        }\n\n      });\n  }\n}\n",null,"var assign = assign || require('object.assign');\n\nimport createRequestor from './createRequestor.js';\n\nconst superRes = {};\n\nfunction generateDefaultActions(url, defaultParams) {\n  const resource = {};\n\n  resource.get = createRequestor(url, defaultParams);\n  resource.query = resource.get;\n  resource.save = createRequestor(url, defaultParams, {method: 'POST'});\n  resource.put = createRequestor(url, defaultParams, {method: 'PUT'});\n  resource.remove = createRequestor(url, defaultParams, {method: 'DELETE'});\n  resource['delete'] = resource.remove;\n\n  return resource;\n}\n\nsuperRes.resource = (url, defaultParams, actions) => {\n  const resource = generateDefaultActions(url, defaultParams);\n  if (actions) {\n    Object.getOwnPropertyNames(actions).forEach((name) => {\n      resource[name] = createRequestor(url, defaultParams, actions[name]);\n    });\n  }\n  return resource;\n};\n\nsuperRes.promiseWrapper = function promiseWrapper(wrapperFunc) {\n  return (resource) => {\n    let proxiedResource = assign({}, resource);\n    Object.getOwnPropertyNames(resource).forEach((name) => {\n      let actionFunction = proxiedResource[name];\n      proxiedResource[name] = function (...args) {\n        let promise = actionFunction.apply(proxiedResource, args);\n        return wrapperFunc(promise);\n      }\n    });\n    return proxiedResource;\n  }\n};\n\nexport default superRes;\n","'use strict';\n\nimport request from 'superagent';\nimport Q from 'q';\n\nvar exports = {};\n\nexports.configureRequest = function configureRequest(config, url, dataTransformer) {\n    const method = config.method.toLowerCase();\n    let currentRequest = request[method === 'delete' ? 'del' : method](url);\n\n    currentRequest = currentRequest.accept(config.responseType);\n    if (config.headers) {\n        currentRequest = currentRequest.set(config.headers);\n    }\n\n    if (config.timeout) {\n        currentRequest.timeout(config.timeout);\n    } else {\n        currentRequest.clearTimeout();\n    }\n\n    if (config.withCredentials) {\n        currentRequest = currentRequest.withCredentials();\n    }\n\n    const transformedData = dataTransformer(currentRequest.header);\n    if (transformedData) {\n        if (method === 'get') {\n            currentRequest = currentRequest.query(transformedData);\n        } else {\n            currentRequest = currentRequest.send(transformedData);\n        }\n    }\n\n    return currentRequest;\n};\n\nexports.makeRequest = function makeRequest(request) {\n    const deferred = Q.defer();\n    request.end((err, res) => {\n        if (err) {\n            deferred.reject(err);\n        } else {\n            deferred.resolve(res);\n        }\n    });\n    return deferred.promise;\n};\n\nexport default exports;","export default actionDefaults = {\n  method: 'GET',\n  responseType: 'json',\n  transformRequest: [],\n  transformResponse: [],\n  withCredentials: false,\n  cache: null\n};"],"sourceRoot":"/source/"}